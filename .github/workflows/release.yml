name: Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:

jobs:
  test:
    name: Unit Tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: stable
          check-latest: true

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: "lts/*"
          check-latest: true
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install Linux Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            pkg-config \
            libgtk-3-dev \
            libwebkit2gtk-4.1-dev \
            libjavascriptcoregtk-4.1-dev \
            libglib2.0-dev \
            libpango1.0-dev \
            libcairo2-dev \
            libgdk-pixbuf-2.0-dev \
            libsoup-3.0-dev \
            libharfbuzz-dev \
            libatk1.0-dev

      - name: Install frontend dependencies
        run: npm install --prefix frontend

      - name: Create placeholder bindings (for compilation)
        run: |
          mkdir -p frontend/bindings/github.com/XgzK/intellijapp/internal/service
          echo "// Placeholder for CI testing" > frontend/bindings/github.com/XgzK/intellijapp/internal/service/index.ts

      - name: Create placeholder frontend dist (for embed)
        run: |
          mkdir -p frontend/dist
          echo "<!DOCTYPE html><html><body>Test</body></html>" > frontend/dist/index.html

      - name: Run go test
        run: go test ./...

  package:
    name: Package Applications
    runs-on: ${{ matrix.os }}
    needs: test
    strategy:
      fail-fast: false
      matrix:
        include:
          # Windows - NSIS only (MSIX not supported in current Wails v3)
          - os: windows-latest
            platform: windows
            formats: "nsis"
          # macOS - .app bundle
          - os: macos-latest
            platform: darwin
            formats: "app"
          # Linux - All formats
          - os: ubuntu-latest
            platform: linux
            formats: "appimage,deb,rpm"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: stable
          check-latest: true

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: "lts/*"
          check-latest: true
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install Linux Dependencies
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            pkg-config \
            libgtk-3-dev \
            libwebkit2gtk-4.1-dev \
            libjavascriptcoregtk-4.1-dev \
            libglib2.0-dev \
            libpango1.0-dev \
            libcairo2-dev \
            libgdk-pixbuf-2.0-dev \
            libsoup-3.0-dev \
            libharfbuzz-dev \
            libatk1.0-dev \
            nsis \
            rpm \
            gcc-aarch64-linux-gnu \
            g++-aarch64-linux-gnu

      - name: Install Wails CLI (Linux)
        if: runner.os == 'Linux'
        run: |
          # Set CGO flags to help linker find libraries
          export CGO_ENABLED=1
          export PKG_CONFIG_PATH=/usr/lib/x86_64-linux-gnu/pkgconfig:$PKG_CONFIG_PATH
          go install github.com/wailsapp/wails/v3/cmd/wails3@latest

      - name: Install Wails CLI (Non-Linux)
        if: runner.os != 'Linux'
        run: go install github.com/wailsapp/wails/v3/cmd/wails3@latest

      - name: Install Task CLI
        run: go install github.com/go-task/task/v3/cmd/task@latest

      - name: Install WebView2 Runtime
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          # Windows runners usually have WebView2 pre-installed
          # If not, download the x64 installer only (skip ARM64 for now)
          $installer = 'MicrosoftEdgeWebView2RuntimeInstallerX64.exe'
          $downloadUrl = "https://go.microsoft.com/fwlink/p/?LinkId=2124703"
          $installerPath = Join-Path $env:TEMP $installer
          try {
            Invoke-WebRequest -Uri $downloadUrl -OutFile $installerPath -UseBasicParsing -ErrorAction Stop
            Start-Process -FilePath $installerPath -ArgumentList '/silent','/install' -NoNewWindow -Wait
            Remove-Item $installerPath -Force
          } catch {
            Write-Host "WebView2 may already be installed or download failed. Continuing..."
          }

      - name: Install NSIS (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          choco install nsis -y
          $env:PATH += ";C:\Program Files (x86)\NSIS"
          echo "C:\Program Files (x86)\NSIS" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

      - name: Build Application
        run: task build
        env:
          PRODUCTION: "true"

      - name: List build output (debug)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          Write-Host "=== Checking bin directory ==="
          if (Test-Path "bin") {
            Get-ChildItem bin -Recurse | Format-Table Name, Length, FullName
          } else {
            Write-Host "bin directory does not exist!"
          }
          Write-Host "=== Current directory ==="
          Get-Location
          Get-ChildItem . | Format-Table Name

      - name: Package Windows NSIS (amd64)
        if: runner.os == 'Windows' && contains(matrix.formats, 'nsis')
        run: |
          $env:ARCH = "amd64"
          task windows:create:nsis:installer
        shell: pwsh

      - name: Package Windows NSIS (arm64)
        if: runner.os == 'Windows' && contains(matrix.formats, 'nsis')
        run: |
          $env:ARCH = "arm64"
          task windows:create:nsis:installer
        shell: pwsh

      # MSIX packaging disabled - not supported in current Wails v3 version
      # - name: Package Windows MSIX
      #   if: runner.os == 'Windows' && contains(matrix.formats, 'msix')
      #   run: task windows:create:msix:package
      #   continue-on-error: true  # MSIX requires certificates

      - name: Rename Windows packages
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          # Extract version from tag (e.g., v1.0.2 -> 1.0.2)
          $VERSION = $env:GITHUB_REF -replace '^refs/tags/v', ''

          # Rename amd64 files with standardized naming
          if (Test-Path "bin\intellijapp-amd64-installer.exe") {
            Rename-Item "bin\intellijapp-amd64-installer.exe" "intellijapp-${VERSION}-windows-amd64-installer.exe"
          }
          if (Test-Path "bin\intellijapp.exe") {
            Rename-Item "bin\intellijapp.exe" "intellijapp-${VERSION}-windows-amd64.exe"
          }

          # Rename arm64 files with standardized naming
          if (Test-Path "bin\intellijapp-arm64-installer.exe") {
            Rename-Item "bin\intellijapp-arm64-installer.exe" "intellijapp-${VERSION}-windows-arm64-installer.exe"
          }

      - name: Package macOS App (arm64)
        if: runner.os == 'macOS'
        run: |
          ARCH=arm64 PRODUCTION=true task darwin:build
          task darwin:create:app:bundle
          mv bin/intellijapp.app bin/intellijapp-arm64.app

      - name: Package macOS App (amd64)
        if: runner.os == 'macOS'
        run: |
          ARCH=amd64 PRODUCTION=true task darwin:build
          task darwin:create:app:bundle
          mv bin/intellijapp.app bin/intellijapp-amd64.app

      - name: Rename macOS packages
        if: runner.os == 'macOS'
        run: |
          # Extract version from tag (e.g., v1.0.2 -> 1.0.2)
          VERSION=${GITHUB_REF#refs/tags/v}

          cd bin

          # Copy install script to package directory and make it executable
          if [ -f "../install.sh" ]; then
            cp ../install.sh .
            chmod +x install.sh
          fi

          # Zip arm64 version with install script
          if [ -d "intellijapp-arm64.app" ]; then
            zip -r "intellijapp-${VERSION}-darwin-arm64.app.zip" intellijapp-arm64.app install.sh
            rm -rf intellijapp-arm64.app
          fi

          # Zip amd64 version with install script
          if [ -d "intellijapp-amd64.app" ]; then
            zip -r "intellijapp-${VERSION}-darwin-amd64.app.zip" intellijapp-amd64.app install.sh
            rm -rf intellijapp-amd64.app
          fi

          # Clean up temporary files
          rm -f intellijapp intellijapp-amd64 intellijapp-arm64 install.sh

          cd ..

      - name: Package Linux AppImage
        if: runner.os == 'Linux' && contains(matrix.formats, 'appimage')
        run: task linux:create:appimage
        continue-on-error: true

      - name: Package Linux DEB
        if: runner.os == 'Linux' && contains(matrix.formats, 'deb')
        run: task linux:create:deb
        continue-on-error: true

      - name: Package Linux RPM
        if: runner.os == 'Linux' && contains(matrix.formats, 'rpm')
        run: task linux:create:rpm
        continue-on-error: true

      - name: Rename Linux packages
        if: runner.os == 'Linux'
        run: |
          # Extract version from tag (e.g., v1.0.2 -> 1.0.2)
          VERSION=${GITHUB_REF#refs/tags/v}

          # Rename files with standardized naming
          [ -f "bin/intellijapp-x86_64.AppImage" ] && mv "bin/intellijapp-x86_64.AppImage" "bin/intellijapp-${VERSION}-linux-amd64.AppImage"
          [ -f "bin/intellijapp.deb" ] && mv "bin/intellijapp.deb" "bin/intellijapp-${VERSION}-linux-amd64.deb"
          [ -f "bin/intellijapp.rpm" ] && mv "bin/intellijapp.rpm" "bin/intellijapp-${VERSION}-linux-amd64.rpm"

          # Clean up temporary binary files
          rm -f bin/intellijapp

      - name: Upload Package Artifacts
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: packages-${{ matrix.platform }}
          path: bin/
          if-no-files-found: error

  release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs:
      - test
      - package
    permissions:
      contents: write
    env:
      NODE_ENV: production

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Required for changelog generation

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: stable
          check-latest: true

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: "lts/*"
          check-latest: true
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      # Wails CLI and Task CLI not needed in release job
      # Packages are already built by package job

      - name: Download Windows Packages
        uses: actions/download-artifact@v4
        with:
          name: packages-windows
          path: bin/

      - name: Download macOS Packages
        uses: actions/download-artifact@v4
        with:
          name: packages-darwin
          path: bin/

      - name: Download Linux Packages
        uses: actions/download-artifact@v4
        with:
          name: packages-linux
          path: bin/

      - name: List Downloaded Files
        run: |
          echo "=== Downloaded Packages ==="
          ls -lhR bin/

      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Extract tag name
          TAG_NAME=${GITHUB_REF#refs/tags/}

          # Find all package files, excluding .app directory contents
          PACKAGES=$(find ./bin -maxdepth 1 -type f | tr '\n' ' ')

          echo "Found packages: $PACKAGES"

          # Try to create release with packages
          if gh release create "$TAG_NAME" \
            --draft \
            --title "Release $TAG_NAME" \
            --notes "See [CHANGELOG](https://github.com/${{ github.repository }}/compare/v1.0.1...$TAG_NAME) for details." \
            $PACKAGES 2>&1 | tee /tmp/gh_output.txt; then
            echo "Release created successfully"
          else
            # Check if release already exists
            if grep -q "already exists" /tmp/gh_output.txt; then
              echo "Release already exists, uploading files..."
              if [ -n "$PACKAGES" ]; then
                gh release upload "$TAG_NAME" $PACKAGES --clobber
              else
                echo "No packages found to upload"
              fi
            else
              echo "Failed to create release"
              cat /tmp/gh_output.txt
              exit 1
            fi
          fi
